using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Security.Cryptography;
using System.IO;

class Program
{
    /*
     *  예를 들어 키는 57616C6B697A3532383332694C6F636B 입니다.
        토큰을 얻기 위한 일반 텍스트 명령은 다음과 같습니다. 030000000000000000000000000000000
        암호화된 버전은 39E1CBB7EFC7127DE387EDF4A0075D66 입니다
                       39e1cbb7efc7127de387edf4a0075d66


        5.	잠금해제
        예를 들어 키는 57616C6B697A3532383332694C6F636B 입니다.
        예를 들어 잠금 해제 비밀번호는 313130303634 입니다.
        예를 들어 토큰은 AB568E21 입니다.
        잠금을 해제하는 일반 텍스트 명령은 다음과 같습니다.
        200031313030363400000000AB568E21
        암호화된버전은 70E8CDAD64B0E3061FA5ACB22EE52AA0 입니다
     */
    static byte[] key = { 0x57,0x61,0x6C,0x6B,0x69,0x7A,0x35,0x32,0x38,0x33,0x32,0x69,0x4C,0x6F,0x63,0x6B };
    public static void Main()
    {
        // See https://aka.ms/new-console-template for more information
        Console.WriteLine("Hello, World!!!");

        byte[] src = { 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
        string encStr = Encrypt(key, src);
        Console.WriteLine($"key ===> {UTF8Encoding.UTF8.GetString(key)}");
        Console.WriteLine($"Encrypt ===> {encStr}");
        Console.WriteLine($"Decrypt ===> {Decrypt(key, encStr)}");

        String s = "TEST08";
        String keys = "nfaator!plaeemo!";
        Console.WriteLine($"[40] ===> {Encrypt(s, key)}");
        Console.WriteLine($"[41] ===> {Decrypt(Encrypt(s, key), key)}");
    }

    private static string Encrypt(byte[] KeyArray, byte[] EncryptArray)
    {
        RijndaelManaged Rdel = new RijndaelManaged();
        Rdel.Mode = CipherMode.ECB;
        Rdel.Padding = PaddingMode.Zeros;
        Rdel.Key = KeyArray;

        ICryptoTransform CtransForm = Rdel.CreateEncryptor();
        byte[] ResultArray = CtransForm.TransformFinalBlock(EncryptArray, 0, EncryptArray.Length);

        return ByteToHex(ResultArray);
    }

    private static string Encrypt(string s, byte[] KeyArray)
    {
        StringBuilder sbResult = new StringBuilder();

        byte[] EncryptArray = UTF8Encoding.UTF8.GetBytes(s);

        RijndaelManaged Rdel = new RijndaelManaged();
        Rdel.Mode = CipherMode.ECB;
        Rdel.Padding = PaddingMode.Zeros;
        Rdel.Key = KeyArray;

        ICryptoTransform CtransForm = Rdel.CreateEncryptor();
        byte[] ResultArray = CtransForm.TransformFinalBlock(EncryptArray, 0, EncryptArray.Length);

        foreach (byte b in ResultArray)
        {
            sbResult.AppendFormat("{0:x2}", b);
        }

        return sbResult.ToString();
    }

    private static string Decrypt(byte[] KeyArray, string EncryptStr)
    {
        byte[] EncryptArray = HexToByte(EncryptStr);

        RijndaelManaged Rdel = new RijndaelManaged();
        Rdel.Mode = CipherMode.ECB;
        Rdel.Padding = PaddingMode.Zeros;
        Rdel.Key = KeyArray;

        ICryptoTransform CtransForm = Rdel.CreateDecryptor();
        byte[] ResultArray = CtransForm.TransformFinalBlock(EncryptArray, 0, EncryptArray.Length);
        return UTF8Encoding.UTF8.GetString(ResultArray);
    }

    private static string Decrypt(string EncryptStr, byte[] KeyArray)
    {
        byte[] EncryptArray = HexToByte(EncryptStr);

        RijndaelManaged Rdel = new RijndaelManaged();
        Rdel.Mode = CipherMode.ECB;
        Rdel.Padding = PaddingMode.Zeros;
        Rdel.Key = KeyArray;

        ICryptoTransform CtransForm = Rdel.CreateDecryptor();
        byte[] ResultArray = CtransForm.TransformFinalBlock(EncryptArray, 0, EncryptArray.Length);
        return UTF8Encoding.UTF8.GetString(ResultArray);
    }

    private static string Decrypt(byte[] KeyArray, byte[] EncryptArray)
    {
        try
        {
            RijndaelManaged Rdel = new RijndaelManaged();
            Rdel.Mode = CipherMode.ECB;
            Rdel.Padding = PaddingMode.Zeros;
            Rdel.Key = KeyArray;

            ICryptoTransform CtransForm = Rdel.CreateDecryptor();
            byte[] ResultArray = CtransForm.TransformFinalBlock(EncryptArray, 0, EncryptArray.Length);
            return UTF8Encoding.UTF8.GetString(ResultArray);
        }
        catch (System.Exception ex)
        {
            Console.WriteLine($"ex ===> {ex}");
        }
        return null;
    }

    private static byte[] HexToByte(string msg)
    {
        msg = msg.Replace(" ", "");
        byte[] comBuffer = new byte[msg.Length / 2];
        for(int i = 0; i < msg.Length; i+=2)
        {
            try
            {
                comBuffer[i / 2] = (byte)Convert.ToByte(msg.Substring(i, 2), 16);
            }
            catch(ArgumentOutOfRangeException ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }
        return comBuffer;
    }

    private static String ByteToHex(byte[] ResultArray)
    {
        StringBuilder sbResult = new StringBuilder();
        foreach (byte b in ResultArray)
        {
            sbResult.AppendFormat("{0:x2}", b);
        }

        return sbResult.ToString();
    }

    private static string Encrypt(string s, string key)
    {
        StringBuilder sbResult = new StringBuilder();

        byte[] KeyArray = UTF8Encoding.UTF8.GetBytes(key);
        byte[] EncryptArray = UTF8Encoding.UTF8.GetBytes(s);

        RijndaelManaged Rdel = new RijndaelManaged();
        Rdel.Mode = CipherMode.ECB;
        Rdel.Padding = PaddingMode.Zeros;
        Rdel.Key = KeyArray;

        ICryptoTransform CtransForm = Rdel.CreateEncryptor();
        byte[] ResultArray = CtransForm.TransformFinalBlock(EncryptArray, 0, EncryptArray.Length);

        foreach (byte b in ResultArray)
        {
            sbResult.AppendFormat("{0:x2}", b);
        }

        return sbResult.ToString();
    }

    private static string Decrypt(string s, string key)
    {
        byte[] KeyArray = UTF8Encoding.UTF8.GetBytes(key);
        byte[] EncryptArray = HexToByte(s);

        RijndaelManaged Rdel = new RijndaelManaged();
        Rdel.Mode = CipherMode.ECB;
        Rdel.Padding = PaddingMode.Zeros;
        Rdel.Key = KeyArray;

        ICryptoTransform CtransForm = Rdel.CreateDecryptor();
        byte[] ResultArray = CtransForm.TransformFinalBlock(EncryptArray, 0, EncryptArray.Length);
        return UTF8Encoding.UTF8.GetString(ResultArray);
    }

}
